function solveTurnstileMin({ url, proxy, siteKey }) {
    return new Promise(async (resolve, reject) => {

        if (!url) return reject('Missing url parameter')
        if (!siteKey) return reject('Missing siteKey parameter')

        const context = await global.browser.createBrowserContext().catch(() => null);
        if (!context) return reject('Failed to create browser context')

        let isResolved = false

        const { proxyRequest } = await import('puppeteer-proxy')
        const { RequestInterceptionManager } = await import('puppeteer-intercept-and-modify-requests')


        var cl = setTimeout(async () => {
            if (!isResolved) {
                await context.close()
                reject("Timeout Error")
            }
        }, (global.timeOut || 60000))

        try {
            const page = await context.newPage();
            const client = await page.target().createCDPSession()
            const interceptManager = new RequestInterceptionManager(client)

            await page.setRequestInterception(true);
            page.on('request', async (request) => {
                try {
                    if ([url, url + '/'].includes(request.url())) return request.abort()

                    if (proxy) {
                        await proxyRequest({
                            page,
                            proxyUrl: `http://${proxy.username ? `${proxy.username}:${proxy.password}@` : ""}${proxy.host}:${proxy.port}`,
                            request,
                        });
                    } else {
                        request.continue()
                    }
                } catch (e) { request.continue() }
            });

            await interceptManager.intercept(
                {
                    urlPattern: url,
                    resourceType: 'Document',
                    modifyResponse({ body }) {
                        return {
                            body: String(require('fs').readFileSync('./src/data/fakePage.html')).replace(/<site-key>/g, siteKey),
                            status: 200
                        }
                    },
                }
            )
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            await page.goto(url, {
                waitUntil: 'domcontentloaded'
            })
//            await page.waitForSelector('[name="cf-response"]', {
//                timeout: 60000
//            })
            await page.waitForFunction(() => {
                const inputs = document.querySelectorAll('[name="cf-response"]');
                return Array.from(inputs).filter(input => input.value !== '').length >= 10; // 等待至少 9 个输入框的 value 被设置
            }, { timeout: 60000 });


           const tokens = await page.evaluate(() => {
                return Array.from(document.querySelectorAll('[name="cf-response"]'))
                    .map(el => el.value)
                    .filter(Boolean);
            });

//            console.log('提取的 Tokens:', tokens);

           isResolved = true
           clearInterval(cl)
           await context.close()
           if (tokens.length === 0) return reject('Failed to get any token');
           return resolve(tokens); // 返回所有抓取到的 tokens
           } catch (e){
                if (!isResolved){
                    await context.close()
                    clearInterval(cl)
                    reject(e.message)
               }
           }

        })
}
module.exports = solveTurnstileMin
