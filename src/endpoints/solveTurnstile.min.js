const fs = require('fs');
const path = require('path');

// â˜… æ–‡ä»¶åªè¯»ä¸€æ¬¡ï¼Œç¼“å­˜åœ¨å†…å­˜ä¸­
const fakePageTemplate = fs.readFileSync(
    path.join(__dirname, '../data/fakePage.html'),
    'utf-8'
);

/**
 * solveTurnstileMin - ä¼˜åŒ–ç‰ˆ
 */
async function solveTurnstileMin({ url, proxy, siteKey, count = 10 }) {
    // ============================================
    // 1. å‚æ•°æ ¡éªŒ
    // ============================================
    if (!url) throw new Error('Missing url parameter');
    if (!siteKey) throw new Error('Missing siteKey parameter');

    // ============================================
    // 2. åˆ›å»ºæµè§ˆå™¨ä¸Šä¸‹æ–‡
    // ============================================
    let context = null;
    let page = null;
    let timeoutTimer = null;
    let isCleanedUp = false;

    const timeout = global.timeOut || 600000;
    const pageHtml = fakePageTemplate.replace(/<site-key>/g, siteKey);

    // ç»Ÿä¸€æ¸…ç†å‡½æ•°ï¼ˆä¿è¯åªæ‰§è¡Œä¸€æ¬¡ï¼‰
    const cleanup = async () => {
        if (isCleanedUp) return;
        isCleanedUp = true;

        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = null;
        }

        // å…ˆå…³ pageï¼Œå†å…³ context
        if (page) {
            try {
                // ç§»é™¤æ‰€æœ‰ç›‘å¬å™¨ï¼Œé˜²æ­¢æ³„æ¼
                page.removeAllListeners();
                await page.close();
            } catch (_) {}
            page = null;
        }

        if (context) {
            try {
                await context.close();
            } catch (_) {}
            context = null;
            console.log('ğŸ”’ Context closed');
        }
    };

    try {
        // ============================================
        // 3. è¶…æ—¶æ§åˆ¶ï¼ˆç”¨ AbortController æ€è·¯ï¼‰
        // ============================================
        let timeoutReject;
        const timeoutPromise = new Promise((_, reject) => {
            timeoutReject = reject;
            timeoutTimer = setTimeout(() => {
                reject(new Error('Timeout Error'));
            }, timeout);
        });

        // ä¸»é€»è¾‘åŒ…è£…ä¸º async å‡½æ•°
        const mainTask = async () => {
            // ============================================
            // 4. åˆ›å»º context
            // ============================================
            try {
                context = await global.browser.createBrowserContext({
                    proxyServer: proxy ? `http://${proxy.host}:${proxy.port}` : undefined,
                });
            } catch (e) {
                throw new Error('Failed to create browser context');
            }

            // ============================================
            // 5. åˆ›å»ºé¡µé¢
            // ============================================
            page = await context.newPage();

            // ä»£ç†è®¤è¯
            if (proxy?.username && proxy?.password) {
                await page.authenticate({
                    username: proxy.username,
                    password: proxy.password,
                });
            }

            // ============================================
            // 6. è¯·æ±‚æ‹¦æˆªï¼ˆå®‰å…¨å¤„ç†ï¼‰
            // ============================================
            await page.setRequestInterception(true);

            const onRequest = async (request) => {
                try {
                    // å·²æ¸…ç†åˆ™ç›´æ¥ abort
                    if (isCleanedUp) {
                        await request.abort().catch(() => {});
                        return;
                    }

                    const reqUrl = request.url();
                    const isTarget =
                        (reqUrl === url || reqUrl === url + '/') &&
                        request.resourceType() === 'document';

                    if (isTarget) {
                        await request.respond({
                            status: 200,
                            contentType: 'text/html',
                            body: pageHtml,
                        });
                    } else {
                        await request.continue();
                    }
                } catch (e) {
                    // request å¯èƒ½å·²ç»è¢«å¤„ç†è¿‡äº†ï¼Œå¿½ç•¥
                    // è¿™æ˜¯é˜²æ­¢ "Request is already handled" å´©æºƒçš„å…³é”®
                }
            };

            page.on('request', onRequest);

            // ============================================
            // 7. å¯¼èˆª
            // ============================================
            await page.goto(url, {
                waitUntil: 'domcontentloaded',
                timeout: Math.min(600000, timeout - 5000),
            });

            // ============================================
            // 8. æ”¶é›† tokens
            // ============================================
            const tokens = [];
            const perTokenTimeout = Math.min(
                600000,
	Math.floor(timeout)
                // Math.floor((timeout - 10000) / count) // å‡åˆ†å‰©ä½™æ—¶é—´
            );

            for (let i = 0; i < count; i++) {
                if (isCleanedUp) break;

                try {
                    await page.waitForFunction(
                        (index) => {
                            const el = document.getElementById('cf-response-' + index);
                            return el && el.value && el.value.length > 10;
                        },
                        { timeout: perTokenTimeout, polling: 5000 },
                        i
                    );

                    const token = await page.evaluate((index) => {
                        const el = document.getElementById('cf-response-' + index);
                        return el ? el.value : null;
                    }, i);

                    if (token && token.length > 10) {
                        tokens.push(token);
                        console.log(
                            `[${i + 1}/${count}] âœ… Token obtained (total: ${tokens.length})`
                        );
                    }
                } catch (e) {
                    console.log(`[${i + 1}/${count}] âŒ Skipped: ${e.message}`);
                }
            }

            if (tokens.length === 0) {
                throw new Error('Failed to get any token');
            }

            console.log(`âœ… Done: ${tokens.length}/${count} tokens obtained`);
            return tokens;
        };

        // ============================================
        // 9. ç«é€Ÿï¼šä¸»ä»»åŠ¡ vs è¶…æ—¶
        // ============================================
        const result = await Promise.race([mainTask(), timeoutPromise]);
        return result;

    } finally {
        // â˜… æ— è®ºæˆåŠŸã€å¤±è´¥ã€è¶…æ—¶ï¼Œéƒ½ç¡®ä¿æ¸…ç†
        await cleanup();
    }
}

module.exports = solveTurnstileMin;
